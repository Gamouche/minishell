malloc
free
access ;
open
close
read
write
opendir
readdir
closedir
getcwd ;
chdir ;
stat
lstat
fstat
fork ;  0 si on est dans le fils / PID du fils si on est dans le pere
execve ;
wait ;
waitpid ;
wait3 ;
wait4 ;
signal ;  renvoie SIG_ERR en cas d'erreur
kill ;
exit


echo, cd, setenv, unsetenv, env, exit


--------
ls rien && ;ls || pwd // le parseur marche, mais pour les executions : le premier ls se lance et foire, le second ls n'est pas lance mais le pwd oui !
--------


----
si la commande est * (etoile) ben il faut faie des trucs chiants
----

CAS CHELOU BONUS
"&&"
"||"
";"
"CMD"
'CMD'



1 || ls\& && ls  =>  en fait ls\& ca echappe le & ca donne ls&  donc ca veut lancer le binaire ls&

------------
WIFEXITED(status)

Elle renvoie vrai si le statut provient d'un processus fils qui s'est terminé en quittant le main avecreturnou avec un appel àexit.

WEXITSTATUS(status)

Elle renvoie le code de retour du processus fils passé àexitou àreturn.

Cette macro est utilisable uniquement si vous avez utiliséWIFEXITEDavant, et que cette dernière a renvoyé vrai.

WIFSIGNALED(status)

Elle renvoie vrai si le statut provient d'un processus fils qui s'est terminé à cause d'un signal.

WTERMSIG(status)

Elle renvoie la valeur du signal qui a provoqué la terminaison du processus fils.

Cette macro est utilisable uniquement si vous avez utiliséWIFSIGNALEDavant, et que cette dernière a renvoyé vrai.

EXEMPLE POUR RECUP LA VALEUR DE RETOUR
wait(&status);
if ( WIFEXITED(status) )
	printf("status = %d\n", WEXITSTATUS(status) );
-------------